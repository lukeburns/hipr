#!/usr/bin/env node

const chalk = require('chalk')
const pretty = require('pretty-hash')
const path = require('path')
const util = require('util')
const { spawn } = require('child_process')

const colors = new Map()

if (process.argv[2] === '--path') {
  return process.stdout.write(getPath())
}

if (process.argv[2] === '--install' || process.argv[2] === '-i' || process.argv[2] === 'install' || process.argv[2] === 'i') {
  if (process.argv[3]) {
    const cmd = `npm i --legacy-peer-deps --prefix ${getPath()} ${process.argv.slice(3).join(' ')}`.split(' ')
    spawn(cmd[0], cmd.slice(1), { stdio: 'inherit' })
  } else {
    console.error('No package specified')
  }
  return
}

const HOME = require('os').homedir()

let [serverHost, serverPort] = (process.argv[3] || ':53').split(':')
let [rootHost, rootPort] = (process.argv[4] || ':5349').split(':')
serverHost = serverHost || '127.0.0.1'
serverPort = parseInt(serverPort || 53)
rootHost = rootHost || '127.0.0.1'
rootPort = parseInt(rootPort || 53)

const requires = (process.argv[2] || '').split(':').filter(x => !!x)

const { RecursiveServer, createDS } = require('../index')

const dnssec = process.argv.indexOf('--nodnssec') < 0
const authoritative = process.argv.indexOf('--authoritative') >= 0
const edns = process.argv.indexOf('--noedns') < 0
const tcp = process.argv.indexOf('--notcp') < 0
const inet6 = process.argv.indexOf('--inet6') >= 0
let maxReferrals = process.argv.indexOf('--maxReferrals')
maxReferrals = maxReferrals >= 0 ? process.argv[maxReferrals + 1] : 40

const server = new RecursiveServer({ 
  maxReferrals, 
  tcp, 
  inet6, 
  edns, 
  dnssec, 
  authoritative 
})

server.resolver.setStub(rootHost, rootPort, createDS())

if (process.argv.indexOf('--log') >= 0) {
  server.resolver.on('intercept:req', (claim, name, type, ns) => {
    name = name.split('.').map(label => label.length > 20 ? pretty(label) : label).join('.')
    const { protocol, data } = claim.params
    if (protocol) {
      colors.get(protocol) || colors.set(protocol, color(0.5))
      const c = chalk.rgb(...colors.get(protocol))
      let parent = ns.name.slice(0, ns.name.length-1)
      parent = parent.split('.').map(label => label.length > 20 ? pretty(label) : label).join('.')
      console.log(c`[${protocol}@${parent}]`, `${name} ${type} @ ${pretty(data)}.`+c(protocol))
    }
  })

  server.resolver.on('intercept:res', (claim, name, type, ns, res) => {
    const { protocol, data } = claim.params
    colors.get(protocol) || colors.set(protocol, color(0.5))
    const c = chalk.rgb(...colors.get(protocol))
    if (protocol && res) {
      if (res.answer.length) {
        console.log(c`  → Found answer: ${res.answer.join('\n')}`)
      }
      if (res.authority.length) {
        console.log(c`  → Found authority: ${res.authority.join('\n')}`)
      }
      if (!res.answer.length && !res.authority.length) {
        console.log(c`  → No answer or authority`)
      }
    }
  })

  if (process.argv.indexOf('--verbose') >= 0) {
    server.on('query', (req, res, rinfo) => {
      console.log(util.inspect(req.question[0], { breakLength: Infinity, colors: true }))
      res.answer.length && console.log('   →', res.answer.join('\n'))
    })
    server.on('log', console.log)
    server.on('error', error => {
      console.log(error.message)
    })
  }
}

console.log(`starting hipr@${getVersion()} with dnssec ${dnssec ? 'enabled' : 'disabled'}`)

for (const name of requires) {
  const middleware = requiref(name)
  if (typeof middleware === 'function') {
    const path = require.resolve(name)
    console.log(`loading middleware: ${name}@${getVersion(name)}`)
    server.use(middleware())
  } else {
    console.log(`middleware not found: ${name}`)
  }
}

server.bind(serverPort, serverHost)

console.log(`listening on ${serverHost}:${serverPort}`)
console.log(`resolving with ${rootHost}:${rootPort}`)

function requiref (modulePath) {
  try {
    return require(modulePath)
  }
  catch (e) {
    return false
  }
}

function getPath (p='../') {
  return path.dirname(require.resolve(p))
}

function getVersion (p='../') {
  const dir = getPath(p)
  const json = require(path.join(dir, 'package.json'))
  return json.version
}

// https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
function color (saturation = 0.5) {
  let hue = Math.random()
  hue += 0.618033988749895
  hue %= 1

  return hsv_to_rgb({
    h: hue,
    s: saturation,
    v: 0.95,
  })
}

function hsv_to_rgb ({ h, s, v }) {
  const h_i = Math.floor(6*h)
  const f = 6*h - h_i
  const p = v * (1 - s)
  const q = v * (1 - f*s)
  const t = v * (1 - (1 - f) * s)

  let r, g, b

  if (h_i === 0) [r, g, b] = [v, t, p]
  if (h_i === 1) [r, g, b] = [q, v, p]
  if (h_i === 2) [r, g, b] = [p, v, t]
  if (h_i === 3) [r, g, b] = [p, q, v]
  if (h_i === 4) [r, g, b] = [t, p, v]
  if (h_i === 5) [r, g, b] = [v, p, q]

  return [Math.floor(r*256), Math.floor(g*256), Math.floor(b*256)]
}
